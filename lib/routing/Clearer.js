/*
 *   -= RestNio =-
 *  Made by 7kasper
 * Licensed under MIT
 *   -= RestNio =-
 */

'use strict';

// Imports
/**
 * @typedef {import("../util/PermissionSet")} PermissionSet
 * @typedef {import("../routes/Route").ParamDef} ParamDef 
 * @typedef {import("../routes/Route").ParamCheck} ParamCheck 
 * @typedef {import("../routes/Route").ParamFormatter} ParamFormatter 
 */

// Consts
const paramPermissionRegex = /\:([^., ,-]+)/g;

/**
 * @exports Clearer
 * @class Clearer
 * @author 7kasper
 * @classdesc
 * Utility class to 'clear' a route before its function gets executed.
 * Clearing entails that permissions are checked, parameters are verified
 * by the checks and pre-checks inside the route-definition and also
 * that the parameters are sanitised and formatted also according to
 * the route definition. All these checks are in this clearing-class
 * splitted into a few methods.
 */
class Clearer {

    /**
     * Verifies all non-parameter specific permissions
     * and compiles a list of all not-yet-checked
     * parameter specific permissions.
     * The parameter specific permissions ought to be checked
     * after the parameters have been checked and sanitiz
     * @param {string[]} requiredPermissions 
     * @param {PermissionSet} clientPermissions 
     */
    static async clearPermissions(requiredPermissions, clientPermissions) {
        let paramPermissions = new Set();
        for (let requiredPermission of requiredPermissions) {
            if (paramPermissionRegex.test(requiredPermission)) {
                paramPermissions.add(requiredPermission);
            } else if (!clientPermissions.has(requiredPermission)) {
                throw [403, `Missing permission: ${requiredPermission}!`];
            }
        }
        return paramPermissions;
    }

    /**
     * Verifies the client has all permissions.
     * The parameters in the permission list are replaced with values
     * of the parameters present.
     * This is usually a list of parameters generated by the function
     * `clearPermissions();` 
     * @param {string[]} paramPermissions - a list of permissions required to execute the function.
     * @param {PermissionSet} clientPermissions - the permissions the client has.
     * @param {Object.<string, Object>} params - a map of paramnames and the values belonging to them.
     */
    static async clearParamPermissions(paramPermissions, clientPermissions, params) {
        for (let paramPermission of paramPermissions) {
            let requiredPermission = paramPermission.replace(paramPermissionRegex, (match, paramname) => {
                return params[paramname];
            });
            if (!clientPermissions.has(requiredPermission)) {
                throw [403, `Missing param-permission: ${requiredPermission}!`];
            }
        }
        return;
    }

    /**
     * Verifies and sanitises all params.
     * @param {Object.<string, ParamDef>} paramdefs - a map of paramnames and their param definitions. 
     * @param {Object.<string, Object>} params - a map of paramnames and the values belonging to them.
     * @returns params, formatted and well.
     * @throws an error upon failed param check or format.
     */
    static async clearParams(paramdefs, params) {
        process.stdout.write('<-'); console.log(params); //TODO remove debug.
        for (let paramname in paramdefs) {
            let paramdef = paramdefs[paramname];
            let param = params[paramname];
            params[paramname] = this.clearParam(paramdef, param, paramname);
        }
        return params;
    }

    /**
     * Verifies and sanitises a param.
     * @param {ParamDef} paramdef 
     * @param {Object} param 
     * @param {string} paramname 
     */
    static clearParam(paramdef, param, paramname) {
        // Present check
        if (param === undefined || (paramdef.ignoreEmptyString && param === '')) {
            if (paramdef.required) {
                throw [400, `Missing param ${paramname}!`];
            } else if (paramdef.default !== undefined) {
                if (typeof paramdef.default === 'function') {
                    param = paramdef.default(paramname);
                } else {
                    param = paramdef.default;
                }
            }
        } else {
            // Type check
            if (paramdef.type !== undefined && typeof param !== paramdef.type) {
                throw [400, `Incorrect param type: ${typeof param}, ${paramname} should be ${paramdef.type}!`];
            }
            // Custom pre-checks
            this.checkParam(paramdef.prechecks, param, paramname, 'Pre-Check');
            // Custom formats
            param = this.formatParam(paramdef.formatters, param, paramname);
            // Custom checks
            this.checkParam(paramdef.checks, param, paramname, 'Check');
        }
        return param;
    }

    /**
     * Check can fail by using throw, or returning false.
     * @param {ParamCheck[]} checks - a list of parameter checks to run on this parameter.
     * @param {Object} param - the actual value of the param to be checked.
     * @param {string} checktype - mainly used to distinguish `Check`s
     * from `Pre-Check`s. This is used for the standard rejection messages
     * if a simple false is returned in the ParamCheck.
     */
    static checkParam(checks, param, paramname, checktype = 'Check') {
        if (checks) {
            checks.forEach((check, index) => {
                if (check(param, paramname, index) === false) {
                    throw [400, `${checktype} ${index} failed for param ${paramname}!`];
                }
            });
        }
    }

    /**
     * Format can fail by using throw. 
     * Param is always altered to return value.
     * @param {ParamFormatter[]} formatters - a list of formatters to apply to this parameter.
     * @param {Object} param - the value of the actual parameter to be formatted.
     * @returns param, formatted and well.
     */
    static formatParam(formatters, param, paramname) {
        if (formatters) {
            formatters.forEach((formatter, index) => {
                param = formatter(param, paramname, index);
            });
        }
        return param;
    }

}
module.exports = Clearer;